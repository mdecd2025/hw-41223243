var tipuesearch = {"pages": [{'title': 'About', 'text': '課程名稱: 協同產品設計實習 - Collaborative Product Design Practice \n 學員作業網站:\xa0 https://mdecd2025.github.io/hw-41223243/content/index.html \n 學員作業倉儲:  https://github.com/mdecd2025/hw-41223243 \n \n 課程代號: cd2025 \n Teams 線上教學: \n 以 "學號@nfu.edu.tw" 登入 \xa0 https://login.microsoftonline.com/ \xa0 Office 365 \n Teams 團隊代碼:\xa0 p5z4eku \n \n 課程評分: \n Homework (30%) - 每週至少提交兩次與課程進度有關的內容, 完成後填回自評表單 \n Exam (40%) - 建立包含操作流程影片、心得以及提供檔案下載的網頁後填回自評表單 \n Final Report (30%) - 利用網頁內容進行簡報並提交 pdf 格式書面報告, 完成後填回自評表單 \n \n', 'tags': '', 'url': 'About.html'}, {'title': 'repo', 'text': '\n 除了上學期所使用的python310外 還額外新增了python313。 \n', 'tags': '', 'url': 'repo.html'}, {'title': 'Tasks', 'text': '??? \n', 'tags': '', 'url': 'Tasks.html'}, {'title': 'task1', 'text': '組員名單: 41223221 、 41223212 、 41223211 、 41223243 、 41223245 、 41223251 。 \n 首先是初版，這個版本有些問題，就是他會額外找出兩個不相關的，第一個是scrm-1與github.com，而且他無法根據使用者的名稱來自動修改網址。以我的為例: https://github.com/mdecd2025/hw-41223243 \n 我的能跑出來是因為我的使用者名稱是41223243，而我們的組員當中有些人的使用者名稱不等於學號，所以拿第一版去跑Brython，他會假設所有人都是 https://github.com/mdecd2025/hw-學號\xa0 這個樣子，那如果hw-後方不是學號他就讀不到。 \n 然後是二版，二版解決了跳出不相干人員的問題，但第二個問題還是沒有解決，所以以這個東西為基準，我延伸出了第三版。 \n 三版算是一個比較折衷的作法，他能根據帳號去讀取使用者的名稱，如果使用者名稱不等於學號時，那他就會根據使用者名稱去修改hw-的後綴，假設我的使用者名稱是41223243，與帳號相同則hw-學號，而當兩者不同時，他會根據使用者名稱去自動修改成hw-使用者名稱。 \n (以下為AI解釋) \n 這段程式碼是基於  Brython  開發的，目的是從一個指定的 URL ( https://mde.tw/list/2b.txt ) 讀取學員的學號與帳號資料，並根據提供的學號清單顯示每位學員的帳號與對應的 GitHub 倉儲連結。如果帳號名稱與學號不一致，它會使用帳號名稱來生成 GitHub 倉儲 URL，反之則使用學號生成 URL。 \n 以當前來說是夠用的。 \n 以下為三版。 \n \xa0 \n from browser import html, document, window\n   \n# 設定資料來源 URL\nurl = "https://mde.tw/list/2b.txt"\n   \n# 特定學員的學號列表\ntarget_student_ids = ["41223243", "41223221", "41223211", "41223245", "41223251", "41223212"]  # 您指定的學號\n   \n# 利用 AJAX 來讀取遠端資料\ndef fetch_data():\n    # 使用 window.XMLHttpRequest 發送 HTTP GET 請求來讀取資料\n    xhr = window.XMLHttpRequest.new()\n    xhr.open("GET", url, True)\n       \n    # 定義資料載入完成後的處理邏輯\n    def onload(event):\n        # 檢查 HTTP 請求是否成功\n        if xhr.status == 200:\n            # 取得返回的資料\n            data = xhr.responseText.splitlines()\n               \n            # 進行診斷，確保資料格式正確\n            print(f"載入的資料：{data}")\n   \n            # 跳過標題行，獲取有效學員資料\n            all_stud = data[1:]  # 跳過標題行\n            print(f"有效學員資料：{all_stud}")\n   \n            # 顯示資料\n            brython_div1 = document["brython_div1"]\n   \n            # 清空顯示區域，避免重複顯示\n            brython_div1.clear()\n   \n            # 顯示特定學員資料及超連結\n            found_count = 0  # 記錄找到的學員數量\n   \n            for idx, stud in enumerate(all_stud, 1):\n                # 假設每一行資料格式為 "學號 帳號"\n                stud_info = stud.strip().split()\n                if len(stud_info) == 2:  # 確保格式正確\n                    student_id, account = stud_info\n                       \n                    # 檢查該學號是否在目標學號列表中\n                    if student_id in target_student_ids:\n                        # 檢查學號與帳號名稱是否一致\n                        if not account.startswith(f"hw-{student_id}"):\n                            # 如果學號與帳號名稱不一致，將倉儲 URL 改為 hw-帳號\n                            link = f"https://github.com/mdecd2025/hw-{account}"\n                        else:\n                            # 如果一致，使用學號來生成倉儲 URL\n                            link = f"https://github.com/mdecd2025/hw-{student_id}"\n                           \n                        brython_div1 <= html.BR()\n                        brython_div1 <= f"{idx}. 學號: {student_id} 帳號: " + html.A(account, href=link)\n   \n                        found_count += 1\n   \n            # 如果沒有找到學員資料，顯示提示信息\n            if found_count == 0:\n                brython_div1 <= html.BR()\n                brython_div1 <= "未找到指定學號的資料。"\n   \n    # 設定載入完成時的回呼\n    xhr.bind("load", onload)\n    xhr.send()\n   \n# 進行資料讀取\nfetch_data() \n \n \n \n', 'tags': '', 'url': 'task1.html'}, {'title': 'task2', 'text': '以ipv6位置開啟近端。 \n \n', 'tags': '', 'url': 'task2.html'}, {'title': 'task3', 'text': '利用cmd開啟並編輯動態倉儲。 \n \n 外部連結改為IPV6的指定位置。 \n 靜態網站 端口:8000\xa0 靜態網站 \n \n 修改的內容 \n 上方壓縮檔包含三個被我更改的.py 是讓近端的網址變成指定ipv6 \n 本人IPV6:2001:288:6004:17:fff1:cd25:0:b053 \n 而靜態網站的端口則使用了8000與8443兩個 不論哪種都能看見靜態網站內容，且內容一致。 \n', 'tags': '', 'url': 'task3.html'}, {'title': 'task4', 'text': '', 'tags': '', 'url': 'task4.html'}, {'title': 'task5', 'text': '', 'tags': '', 'url': 'task5.html'}, {'title': 'task6', 'text': '', 'tags': '', 'url': 'task6.html'}, {'title': 'Homework', 'text': '作業 (30%) \n HW1 (5%):  建立由 Box 組成的平面四連桿機構 Webots 模擬場景 \n part1: \n 請各學員在 USB 隨身碟或個人電腦上完成 cd2025 課程所需的可攜系統配置: \n 下載  portable_wcm2025.7z  (330MB, 解開壓縮後 1.4GB) \n Webots_2025a.7z  (1.5 GB, 解開後約為 2.9GB, 可單獨運作) \n Webots_2025a_web.7z  (171 MB, 解開壓縮後約為 1GB, 必須連網運作) \n Blender4.2.7z \n part2: \n 請各學員完成可攜程式系統配置後, 利用 Webots R2025a 中寬度與高度都為 0.1m 的 box 物件建立一個簡單的平面四連桿機構模擬場景. \n base (基座) 長度 1m, link1 長度 0.4m, link2 長度 0.6m, link3 長度 0.9m, 各轉軸均為 HingeJoint, joint1 旋轉速度設定為 1radian/sec. \n part3: \n 模擬場景啟動後, 按下 s 鍵機構開始作動, 按下 p 鍵後機構暫停. \n 參考資料: \n cd2025_hw1_demo.7z \n HW2 (5%):  建立由 CAD 繪製零件組成的平面四連桿機構 Webots 模擬場景 \n 各學員請利用 CAD 系統依據 HW1 的連桿尺寸與運動方式, 配置適當大小的旋轉軸以及基座後, 利用 Webots R2025a 完成一個簡單的平面四連桿機構模擬場景. \n 參考資料: \n fourbar_slvs.7z \n HW3 (20%): 建立 Webots 桌上籃球遊戲機模擬系統 \n 請各分組利用CAD 系統建立一個能在電腦桌 (1600W X 700D X 740H mm) 上運作的投籃機構 ( 參考影片 )後, 導入 Webots R2025a 套件, 建立一個能由使用者透過鍵盤按鍵操作, 且具備計分板的籃球遊戲機模擬系統. \n 參考資料: \n 參考資料: \n fourbar_ball_throwing_linkage.slvs \n sixbar_ball_throwing_linkage.slvs \n \n', 'tags': '', 'url': 'Homework.html'}, {'title': 'HW1', 'text': 'HW1 (5%):  建立由 Box 組成的平面四連桿機構 Webots 模擬場景 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 HW1 - 學員學號 \n 建造一個robot，然後於children中增加兩個hinge joint與1個solid。 \n 於solid的部分，將其改名為base，並於solid的 children，右鍵新增一個shape，然後於geometry處對他按右鍵新增 box，將X的部分調為1米。 \n ※之後將不再贅述建立box的步驟。 \n 任選一hinge joint，將選擇的hinge joint改名為hinge joint1，另一個改名為hinge joint4。 \n 進入hinge joint1的主線程下方，選擇它的endpoint右鍵新增 solid，然後調整數值。 \n rotation的部分隨意調整，屬於初始角度。 \n 然後children處新增pose與hinge joint，將hinge joint改名為joint2。 \n 然後是joint2的部分與joint1的步驟相同，一樣在children新增solid然後建立pose(box中心)以及一個hinge joint，然後改名為joint3，然後建立第三個box \n 至此box部分結束，接著開始設置jointparameters部分。 \n jointparameters部分其實就是連趕座標相對於原始座標的位置，即與0.0.0相對的位置，例如link1的座標跟原點相比，往負的X移動0.5m，achor的X部分就改為-0.5m，lin2與3都是這樣設置。 \n 除此之外，還要再joint1放置一個旋轉馬達，並命名為motor(控制程式中的命名) \n 然後是幫link1、link2、link3建立boundingObject，這個東西的作用就是定義物品物理碰撞的欄位。 \n 我的設置在下方圖片都可以查看。 \n \n 圖片部分 \n link1 \n \n \n boundingObject \n \n link2 \n \n \n boundingObject \n \n link3 \n \n \n boundingObject \n \n 最後是補上joint4。 \n \n 補上影片中未模擬的部分 \n \n   \n', 'tags': '', 'url': 'HW1.html'}, {'title': 'HW2', 'text': 'HW2 (5%):  建立由 CAD 繪製零件組成的平面四連桿機構 Webots 模擬場景 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 HW2 - 學員學號 \n 1.依照線架構約束組裝完成後存檔，並輸出存檔一個stl檔 \n 2.將stl使用"split_stl_to_obj_scale2"進行轉obj檔，在4link.stl這個地方做更改，改為自己取的名字.stl \n 4.進入webot後，先加入Robot群組 \n 5.在Robot群組下的children加入兩個Solid作為base，再加入兩個Hingejoint一個做為joint1一個為joint4 \n 6.webots的操作步驟皆錄至於影片當中。與HW1的操作相差不多，只是box變成由自己於其他CAD軟體中繪製的物件，看是要透過cadshape匯入obj檔案，又或是從shape->mesh匯入檔案，本人選擇後者，方便更改顏色。 \n \n 心得:套用上HW1的概念，把box用mesh取代，就會容易上許多了，我最開始搞不懂的是，為甚麼尺寸進到webots理會變成40M，導致模擬不正常，只會自由落體，有改尺寸後就正常多了。 \n \n', 'tags': '', 'url': 'HW2.html'}, {'title': '平面四連桿', 'text': '所有零件檔: 4連桿零件及本體.zip 此為壓縮檔，解壓後所獲得的內容含6個零件，1個線檔與1個組合檔。 \n 影片內容  \n \n', 'tags': '', 'url': '平面四連桿.html'}, {'title': 'HW3', 'text': 'HW3 (20%): 建立 Webots 桌上籃球遊戲機模擬系統 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 HW3 - 學員學號 \n 操作影片，含模擬。 \n \n 心得:與HW2雷同，比較熟悉後就不覺得特別難，困難點是在裝配時的數值調整。 \n \n', 'tags': '', 'url': 'HW3.html'}, {'title': 'Midterm', 'text': '本課程所繳交的期中成績為學員自評之學習期望成績. \n 期中考週的自評期望成績繳交流程: \n \n 整理先前所完成的各週的進度、作業網頁內容以及心得 \n 拍攝期中自評影片, 上傳至 Youtube 後, 以" 國立虎尾科技大學 - 機械設計工程系 - cd2025 期中自評- 學員學號 "為影片標題後嵌入本頁面中 \n 回填期中自評表單 \n 上傳學員期中成績 \n \n 各週進度:第一周:創建倉儲、第二周到第三周: 各個github前置作業以及班級list整理學習 第四周:solvespace及webot四連桿練習 第五、六周:webots練習。 \n 各週網頁內容: task1 、 task2 、 task3 、 HW1 、 平面四連桿 、 repo \n 期中心得:老實說目前所使用的webots 我個人覺得上手難度、使用方便的程度都遠不如上學期所使用的CoppeliaSim。 \n 光是那個場景樹建立的關係一旦過多，就足以讓人看的眼睛痛，而且匯入檔案、模擬功能我也覺得不如CoppeliaSim 光是學怎麼使用webots就學到快要中風，總結來說，期中我認為處理的不好，進度落後，但很多時候我真的是， 想做一些作業，但看著webots的使用介面，我就只能發呆，而且webots還很容易閃退，這也是導致進度落後的原因之一。 \n 所以這次的期中自評影片我無法拍攝出太多東西，很多時候我光要弄懂就得耗上數個小時，我不可能讓影片已好幾個小時的形式拍攝，所以期中自評影片就大略展示我所做的東西。 \n 期中自評影片: \n \n 大略展示我所完成的作業，因為進度落後加上排錯中，故HW2尚未完成。 \n \n', 'tags': '', 'url': 'Midterm.html'}, {'title': 'Exam', 'text': 'Exam1 (10%): 建立 Webots 基本物件模擬場景 \n 各學員利用 Webots R2025a 套件中的 Shape 物件, 隨堂建立指定的機電系統模擬場景, 並利用 Python 程式進行互動控制. \n Exam2 (10%): 利用 CAD 零組件建立模擬場景\xa0 \n 各學員利用 CAD (Solvespace 與 NX2312), 隨堂建立指定的系統模型零組件後, 導入 Webots R2025a 後, 建立機電系統模擬場景, 並利用 Python 程式進行互動控制. \n Exam3 (20%): Webots 機電模擬場景的協同設計 \n 各分組利用 CAD (Solvespace 與 NX2312), 隨堂建立指定的系統模型零組件後, 導入 Webots R2025a 後, 建立機電系統模擬場景, 並利用 Python 程式進行互動控制. 過程中各學員必須採同步協同模式, 維護從 Github Classroom 取得的分組協同倉儲以及網站. \n 協同分組方式: \n \n 分配學員負責利用 Solvespace 建立系統零組件, 過程中必須將所建構之零組件檔案與繪圖過程影片上傳至分組網頁. \n 分配學員負責利用 NX2312 建立系統零組件, 過程中必須將所建構之零組件檔案與繪圖過程影片上傳至分組網頁. \n 分配學員負責利用 Webots 建立機電系統模擬場景, 並利用 Python 程式進行控制, 過程中必須將建構過程拍成帶有說明字幕的影片上傳至分組網頁. \n \n', 'tags': '', 'url': 'Exam.html'}, {'title': 'Exam1', 'text': 'Exam1 (10%): 建立 Webots 基本物件模擬場景 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam1 - 41223243 \n exam1 \n \n 操作流程: \n 建造一個robot，然後於children中增加兩個hinge joint與1個solid。 \n 於solid的部分，將其改名為base，並於solid的 children，右鍵新增一個shape，然後於geometry處對他按右鍵新增 box，將X的部分調為1米。 \n ※之後將不再贅述建立box的步驟。 \n 任選一hinge joint，將選擇的hinge joint改名為hinge joint1，另一個改名為hinge joint4。 \n 進入hinge joint1的主線程下方，選擇它的endpoint右鍵新增 solid，然後調整數值，如下圖。 \n \n ※注意rotation的部分是需要根據學號來進行調整，本人最後兩碼43，轉成rad就是0.7505rad。 \n 然後children處新增pose與hinge joint，將hinge joint改名為joint2。 \n pose與其shape中的box如下 \n 一號link \n \n 然後是joint2的部分與joint1的步驟相同，一樣在children新增solid然後建立pose(box中心)以及一個hinge joint，然後改名為joint3，然後建立第三個box。 \n 二號link(下方第二章圖是短桿部分的設定) \n \n 三號link \n \n 至此box部分結束，接著開始設置jointparameters部分。 \n joint1的部分 \n \n 除此之外，還要再joint1放置一個旋轉馬達，並命名為motor(控制程式中的命名) \n joint2的部分 \n \n joint3的部分 \n \n 然後是幫link1、link2、link3建立boundingObject \n link1的boundingObject \n \n link2的 boundingObject \n \n link3的 boundingObject \n \n 以上設置完成後套入 這個控制程式 (注意請務必放置於controllers當中，且程式名稱需與資料夾相同)然後在robot的controlle當中開啟即可以模擬。 \n \n 心得:HW1的翻版，pose這個功能運用得當，然後知道該如何更改rotation並且知道angle換算rad就不會遇到太多問題。 \n', 'tags': '', 'url': 'Exam1.html'}, {'title': 'Exam2', 'text': 'Exam2 (10%): 利用 CAD 零組件建立模擬場景 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam2 - 學員學號 \n exam2 \n 1. 依照個人學號的最後兩碼作為依據，我的連桿主動桿訂為1.43而在solve上改為143，浮桿為215，搖桿為233，基座距離為300。 \n 2.依照線架構約束組裝完成後存檔，並輸出存檔一個stl檔 \n 3.將stl使用"split_stl_to_obj_scale2"進行轉obj檔，在4link.stl這個地方做更改，改為自己取的名字.stl \n 4.進入webot後，先加入Robot群組 \n 5.在Robot群組下的children加入兩個Solid作為base，再加入兩個Hingejoint一個做為joint1一個為joint4 \n 6.webots的操作步驟皆路至於影片當中。與exam的操作相差不多，只是box變成由自己於其他CAD軟體中繪製的物件，看是要透過cadshape匯入obj檔案，又或是從shape->mesh匯入檔案，本人選擇後者，方便更改顏色。 \n 7.著重提一下 jointparameters中的anchor數值的設置。joint1為0,0,0、joint2為1.0458,0.9753,0、joint3為1.8008,2.9884,0。這個數值可由solveSpace中進行確定，即joint的位置距離x,y,z軸的距離。 \n \n 心得:與HW2雷同，只是桿長與起始角度有所限制，不算難。 \n', 'tags': '', 'url': 'Exam2.html'}, {'title': 'Exam3', 'text': 'Exam3 (20%): Webots 機電模擬場景的協同設計 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam3 - 學員學號 \n 1.先將ipv6改為事先規範過的個人ipv6，再將自己倉儲中的init.py檔中的ip改為規範的ipv6 \n 2.開啟webot --stream建立網頁串聯阜號，並開啟個人HW1的模擬 \n 3.使用http://localhost:1234/index.html \n 4.將下方網址輸入的localhost改為規範的ipv6。 \n 第一部影片為瀏覽器上模擬，第二部為利用cmd開啟串流功能。 \n 心得:實際上更多是卡在串流部分，自己在試的時候，經常吃不到規定的ipv6，結果後來檢查之下才發現沒有把ipv6用[]框住，導致瀏覽器根本讀不到。挺搞笑又挺搞人心態的。 \n \n \n exam3-2 \n \n exam3-3 \n \n \n', 'tags': '', 'url': 'Exam3.html'}, {'title': 'Final', 'text': '期末協同專案執行過程影片、簡報與 PDf 報告檔案 (六人一組) (30%) \n 題目:  Webots 動態投籃模擬系統的協同設計 \n 說明:  \n 籃框架被配置在一定範圍內, 可隨機慢速前進、後退及左右擺動, 投籃機構系統帶有一定數量的籃球, 被配置在可自由移動的輪車上. \n 操作者可利用鍵盤特定按鍵控制投籃輪車的移動並發射投籃, 每投出一球後系統透過記分板進行計分, 並由送球機構進行補球或移動輪車取球, 遊戲可進行至全部數量籃球投完為止. \n \n 請將期末協同專案執行過程、內容與心得, 製作成影片，配合字幕上傳至 Youtube 後嵌入各階段的期末報告頁面中. \n 影片標題:  國立虎尾科技大學 - 機械設計工程系 - cd2025 期末報告 - 學員學號 - 各階段影片主題 \n \n \n \n \n \n 藉由M跟K來控制投球機的發射，而上下左右則可以控制投球機下方的輪車移動。 \n \n 期末報告與世界檔案 \n 協同產品設計實習期末報告.pdf \n 心得:本學期著重於教學webots的模擬與操作方式，這個過程可以說是困 難重重，不單只是要繪製物件、還要去留意webots裡的每個部件的 安排，然後還要匯入控制程式，有時候模以出來的結果與範例不同， 又要一個一個東西檢查，非常麻煩，甚至有時候可能是物件的名稱與 控制程式不同，可能差個一個字，就會導致無法模擬，然後第一時間 想到的也不會是這問題。 這個期末報告光是重新建立然後刪除錯誤世界這一程序，我就走了 4、5次以上後來真的是對著範例研究很久，才勉強弄出來。 而且還常常因為python的某些套件沒有安裝，導致某些控制程式的失 效，我的狀況更慘，webots甚至不會去讀我可攜裡的ptyhon套件， 而是讀取我電腦裡很久之前下載的，導致套件東缺稀少，東西一開始 模擬就閃退，後來問半天才找到指定webots使用指定python方式， 才解決閃退問題。 總結來說webots雖然開源，但這個程式的操作門檻實在不算低，裡 面的東西牽一髮動全身，少任何一個東西都能導致模擬失敗，但也讓 我藉機學到做這種東西最重要的一點，就是耐心跟細心，當然除此之外，這個webots也會在日後成為我的工具之一，學了不用，那沒有學的必要，必須感謝老師介紹這一個工具給我們。 \n', 'tags': '', 'url': 'Final.html'}, {'title': '投籃機與其輪車程式分析', 'text': 'from controller import Robot, Keyboard\n\n# Constants\nTIME_STEP = 32\nMAX_VELOCITY = 10.0\nANGLE_STEP = 40 * 3.14159 / 180  # 40 degrees in radians\nPOSITION_M = ANGLE_STEP          # +40 deg\nPOSITION_K = 0.0                 # 0 deg\n\n# Initialize robot and keyboard\nrobot = Robot()\ntimestep = int(robot.getBasicTimeStep())\nkeyboard = Keyboard()\nkeyboard.enable(timestep)\n\n# Get devices\ntry:\n    motor = robot.getDevice(\'motor1\')\n    sensor = robot.getDevice(\'motor1_sensor\')\n    sensor.enable(timestep)\n    mechanism_enabled = True\nexcept Exception:\n    mechanism_enabled = False\n\n# Wheel setup (if available)\ntry:\n    wheels = [robot.getDevice(f"wheel{i+1}") for i in range(4)]\n    for wheel in wheels:\n        wheel.setPosition(float(\'inf\'))  # Infinite position to enable velocity control\n        wheel.setVelocity(0)  # Start with zero velocity\n    platform_enabled = True\nexcept Exception:\n    platform_enabled = False\n\n# State machine: which key is allowed to trigger\ncurrent_state = "allow_m"  # Start by allowing \'m\'\n\n# Key debounce\nkey_pressed = {\n    \'k\': False,\n    \'m\': False\n}\n\nwhile robot.step(timestep) != -1:\n    key = keyboard.getKey()\n    \n    # Platform control\n    if platform_enabled:\n        if key == Keyboard.UP:\n            for wheel in wheels:\n                wheel.setVelocity(MAX_VELOCITY)\n        elif key == Keyboard.DOWN:\n            for wheel in wheels:\n                wheel.setVelocity(-MAX_VELOCITY)\n        elif key == Keyboard.LEFT:\n            wheels[0].setVelocity(MAX_VELOCITY)\n            wheels[1].setVelocity(-MAX_VELOCITY)\n            wheels[2].setVelocity(MAX_VELOCITY)\n            wheels[3].setVelocity(-MAX_VELOCITY)\n        elif key == Keyboard.RIGHT:\n            wheels[0].setVelocity(-MAX_VELOCITY)\n            wheels[1].setVelocity(MAX_VELOCITY)\n            wheels[2].setVelocity(-MAX_VELOCITY)\n            wheels[3].setVelocity(MAX_VELOCITY)\n        elif key == ord(\'Q\') or key == ord(\'q\'):\n            print("Exiting...")\n            break\n        else:\n            for wheel in wheels:\n                wheel.setVelocity(0)\n\n    # Motor key control\n    if mechanism_enabled:\n        # Read current motor position (not for relative, but for debug)\n        _current_motor_position = sensor.getValue()\n\n        # M key: only take action if allowed and not held\n        if key == ord(\'M\') or key == ord(\'m\'):\n            if not key_pressed[\'m\'] and current_state == "allow_m":\n                motor.setPosition(POSITION_M)\n                current_state = "allow_k"\n            key_pressed[\'m\'] = True\n        else:\n            key_pressed[\'m\'] = False\n\n        # K key: only take action if allowed and not held\n        if key == ord(\'K\') or key == ord(\'k\'):\n            if not key_pressed[\'k\'] and current_state == "allow_k":\n                motor.setPosition(POSITION_K)\n                current_state = "allow_m"\n            key_pressed[\'k\'] = True\n        else:\n            key_pressed[\'k\'] = False \n fourbar_controller.zip \n 設定馬達要移動的角度值（弧度制）。 \n ANGLE_STEP = 40 * 3.14159 / 180 # 約 0.698 rad（40度） POSITION_M = ANGLE_STEP # 按 M 時設定馬達位置 POSITION_K = 0.0 # 按 K 時設定馬達位置 \n 嘗試取得名為  \'motor1\'  的旋轉馬達與其對應位置感測器（encoder），若失敗，跳過此功能 \n motor = robot.getDevice(\'motor1\') sensor = robot.getDevice(\'motor1_sensor\') \n 按下  M  時會讓馬達轉到 40 度，但只有當目前狀態允許（ allow_m ）時才執行。 \n 一次只能觸發一次：避免按鍵長按重複觸發。 \n if key == ord(\'M\') and current_state == "allow_m":  motor.setPosition(POSITION_M)  current_state = "allow_k" \n 每個輪子設為無限旋轉（velocity control 模式) \n 利用方向鍵控制移動： \n ↑ ：前進 \n ↓ ：後退 \n ← ：轉左（左右輪相反方向） \n → ：轉右 \n 防止使用者連續按同一鍵造成重複設定指令。 \n current_state = "allow_m" # 只能先按 M # M 按過 → allow_k，K 按過 → allow_m，如此循環 \n \n', 'tags': '', 'url': '投籃機與其輪車程式分析.html'}, {'title': 'Supervisor 控制程式分析', 'text': 'from controller import Supervisor, Keyboard\nimport time\nimport random\nimport numpy as np\nimport re\n\n# ----------------- 參數區 -----------------\nHOOP_CENTER = [0.622, -0.103, 0.742838]\nBALL_DEF_PATTERN = re.compile(r"Sphere_\\d+")\nsupervisor = Supervisor()\ntimestep = int(supervisor.getBasicTimeStep())\nkeyboard = Keyboard()\nkeyboard.enable(timestep)\n\nsphere_radius = 0.1\nTRAJECTORY_POINT_RADIUS = 0.03      # 軌跡小球半徑\nTRAJECTORY_POINT_STEP = 0.12        # 軌跡點間最小距離\nTRAJECTORY_MAX_POINTS = 5           # 只保留5個軌跡點\n\nwaiting_ball_def = None\nwaiting_ball_info = None\nlast_key_time = 0\ndebounce_time = 0.5\ndefault_feed_pos = (-0.35, 0.0, 0.9)\nPRINT_INTERVAL = 0.2\n\ncurrent_tracked_def = None\nlast_print_time = time.time()\n\n# 軌跡資料\ntrajectory_points = []  # [(pos, def_name)] 最多五個\n\ndef axis_angle_to_rotation_matrix(axis, angle):\n    x, y, z = axis\n    c = np.cos(angle)\n    s = np.sin(angle)\n    C = 1 - c\n    return np.array([\n        [x*x*C + c,   x*y*C - z*s, x*z*C + y*s],\n        [y*x*C + z*s, y*y*C + c,   y*z*C - x*s],\n        [z*x*C - y*s, z*y*C + x*s, z*z*C + c]\n    ])\n\ndef generate_valid_def_name(base_name="Sphere"):\n    timestamp = int(supervisor.getTime() * 1000)\n    return f"{base_name}_{timestamp}_{random.randint(0, 10000)}"\n\ndef generate_random_color():\n    return random.random(), random.random(), random.random()\n\ndef youbot_local_to_world(local_pos):\n    youbot_node = supervisor.getFromDef(\'youbot\')\n    if youbot_node is None:\n        raise RuntimeError("找不到 DEF 為 youbot 的 Robot 物件")\n    youbot_translation = np.array(youbot_node.getField(\'translation\').getSFVec3f())\n    youbot_rotation = youbot_node.getField(\'rotation\').getSFRotation()\n    youbot_axis = youbot_rotation[:3]\n    youbot_angle = youbot_rotation[3]\n    youbot_rot_mat = axis_angle_to_rotation_matrix(youbot_axis, youbot_angle)\n    rotated = youbot_rot_mat @ np.array(local_pos)\n    world_pos = youbot_translation + rotated\n    return tuple(world_pos)\n\ndef create_static_ball(def_name, world_pos, r, g, b):\n    sphere_string = f"""\n    DEF {def_name} Solid {{\n      translation {world_pos[0]} {world_pos[1]} {world_pos[2]}\n      contactMaterial "ball"\n      children [\n        Shape {{\n          geometry Sphere {{\n            radius {sphere_radius}\n          }}\n          appearance Appearance {{\n            material Material {{\n              diffuseColor {r} {g} {b}\n            }}\n          }}\n        }}\n      ]\n      boundingObject Sphere {{\n        radius {sphere_radius}\n      }}\n    }}\n    """\n    root = supervisor.getRoot()\n    children_field = root.getField("children")\n    children_field.importMFNodeFromString(-1, sphere_string)\n\ndef create_dynamic_ball(def_name, world_pos, r, g, b):\n    sphere_string = f"""\n    DEF {def_name} Solid {{\n      translation {world_pos[0]} {world_pos[1]} {world_pos[2]}\n      contactMaterial "ball"\n      children [\n        Shape {{\n          geometry Sphere {{\n            radius {sphere_radius}\n          }}\n          appearance Appearance {{\n            material Material {{\n              diffuseColor {r} {g} {b}\n            }}\n          }}\n        }}\n      ]\n      boundingObject Sphere {{\n        radius {sphere_radius}\n      }}\n      physics Physics {{\n        mass 0.01\n        density -1\n      }}\n    }}\n    """\n    root = supervisor.getRoot()\n    children_field = root.getField("children")\n    children_field.importMFNodeFromString(-1, sphere_string)\n\ndef create_trajectory_point(pos):\n    """\n    在pos位置新增一個小球作為拋物線軌跡點，回傳DEF名稱。\n    用Transform持有Shape，僅作視覺標記，不影響物理。\n    """\n    def_name = generate_valid_def_name("TrajectoryPt")\n    sphere_string = f"""\n    DEF {def_name} Transform {{\n      translation {pos[0]} {pos[1]} {pos[2]}\n      children [\n        Shape {{\n          geometry Sphere {{\n            radius {TRAJECTORY_POINT_RADIUS}\n          }}\n          appearance Appearance {{\n            material Material {{\n              diffuseColor 1 0.7 0\n              transparency 0.3\n            }}\n          }}\n        }}\n      ]\n    }}\n    """\n    root = supervisor.getRoot()\n    children_field = root.getField("children")\n    children_field.importMFNodeFromString(-1, sphere_string)\n    return def_name\n\ndef delete_trajectory_points():\n    """刪除所有軌跡點"""\n    global trajectory_points\n    for _, def_name in trajectory_points:\n        node = supervisor.getFromDef(def_name)\n        if node:\n            node.remove()\n    trajectory_points.clear()\n\ndef create_static_sphere(supervisor, x, y, z):\n    global waiting_ball_def, waiting_ball_info\n    def_name = generate_valid_def_name()\n    waiting_ball_def = def_name\n    r, g, b = generate_random_color()\n    world_pos = youbot_local_to_world((x, y, z))\n    waiting_ball_info = (world_pos, r, g, b)\n    create_static_ball(def_name, world_pos, r, g, b)\n\ndef activate_dynamic_ball():\n    global waiting_ball_def, waiting_ball_info\n    if waiting_ball_def is None or waiting_ball_info is None:\n        return\n    ball_node = supervisor.getFromDef(waiting_ball_def)\n    if ball_node is not None:\n        ball_node.remove()\n        supervisor.step(int(supervisor.getBasicTimeStep()))\n    world_pos, r, g, b = waiting_ball_info\n    create_dynamic_ball(waiting_ball_def, world_pos, r, g, b)\n    waiting_ball_def = None\n    waiting_ball_info = None\n\ndef is_ball_landed(pos, threshold_z=0.13):\n    """當球z接近地面時視為落地"""\n    return pos[2] < threshold_z\n\nprint("按 A 產生一顆靜止球，按 M 讓球變 dynamic 可擊出（最多只有5個軌跡點跟著球跑，球落地後軌跡自動消失）")\n\nwhile supervisor.step(timestep) != -1:\n    key = keyboard.getKey()\n    current_time = time.time()\n    # 產生球\n    if key == ord(\'A\') and (current_time - last_key_time >= debounce_time):\n        if waiting_ball_def is None:\n            create_static_sphere(supervisor, *default_feed_pos)\n            current_tracked_def = waiting_ball_def\n            delete_trajectory_points()  # 新球產生時清除舊軌跡\n        else:\n            print("還有一顆球等待擊出，請先擊出再產生新球。")\n        last_key_time = current_time\n    # 讓球變動態\n    if key == ord(\'M\') and (current_time - last_key_time >= debounce_time):\n        activate_dynamic_ball()\n        last_key_time = current_time\n\n    # 拋物線軌跡追蹤\n    if current_tracked_def is not None:\n        ball_node = supervisor.getFromDef(current_tracked_def)\n        if ball_node is not None:\n            pos = ball_node.getPosition()\n            # 每 PRINT_INTERVAL 印座標\n            if current_time - last_print_time >= PRINT_INTERVAL:\n                #print(f"球 {current_tracked_def} 絕對座標: [{pos[0]:.4f}, {pos[1]:.4f}, {pos[2]:.4f}]")\n                last_print_time = current_time\n            # 軌跡點：每隔一段距離才加一個，僅保留5個點\n            if (not trajectory_points) or np.linalg.norm(np.array(pos) - np.array(trajectory_points[-1][0])) > TRAJECTORY_POINT_STEP:\n                def_name = create_trajectory_point(pos)\n                trajectory_points.append((pos, def_name))\n                if len(trajectory_points) > TRAJECTORY_MAX_POINTS:\n                    # 移除最舊的點\n                    _, old_def = trajectory_points.pop(0)\n                    node = supervisor.getFromDef(old_def)\n                    if node:\n                        node.remove()\n            # 若球落地，自動清除軌跡\n            if is_ball_landed(pos):\n                delete_trajectory_points()\n        else:\n            # 球消失，停止追蹤並清除軌跡\n            delete_trajectory_points()\n            current_tracked_def = None \n feed_ball.zip \n \n \n create_static_sphere()  → 建立靜止球。 \n \n \n activate_dynamic_ball()  → 將靜止球刪除再重建為有 Physics 的動態球。 \n \n \n current_tracked_def  配合  trajectory_points  管理拋物線視覺點。 \n \n \n 球落地時清軌跡點、球消失時解除追蹤。 \n \n \n 參數與初始化 \n HOOP_CENTER = [0.622, -0.103, 0.742838] BALL_DEF_PATTERN = re.compile(r"Sphere_\\d+") supervisor = Supervisor() timestep = int(supervisor.getBasicTimeStep()) keyboard = Keyboard() keyboard.enable(timestep) \n \n \n 設定籃框中心位置（可擴充用） \n \n \n 使用正則表達式找出球的 DEF 名稱 \n \n \n 啟用 Webots 監督者與鍵盤控制 \n \n \n 核心參數與狀態變數 \n sphere_radius = 0.1 TRAJECTORY_POINT_RADIUS = 0.03 TRAJECTORY_POINT_STEP = 0.12 TRAJECTORY_MAX_POINTS = 5 \n \n \n 設定球與軌跡點的大小、間距與數量限制 \n \n \n 追蹤當前是否有未發射的球、其資訊，以及追蹤的球 ID \n \n \n 工具函式 \n def youbot_local_to_world(local_pos):  # 取得 youbot 的位置與朝向後進行座標轉換 \n 建立球體函式（靜止/動態） \n def create_static_ball(...) def create_dynamic_ball(...) \n 利用 Webots 的  importMFNodeFromString  方法在場景中加入球（ Solid ） \n 軌跡球建立與移除 \n def create_trajectory_point(pos) def delete_trajectory_points() \n 建立小型透明球標示軌跡（ Transform  +  Shape ），僅視覺效果 \n 按鍵邏輯與操作 \n if key == ord(\'A\') ... \n \n \n \n 按  A  鍵產生一顆靜止球（球會出現在機器人上方） \n \n \n 若還有一顆未擊出的球，不允許產生新球 \n \n \n if key == ord(\'M\') ... \n \n \n 按  M  鍵讓目前靜止球「啟動物理引擎」→ 變成動態球，可以掉落 \n \n \n 軌跡追蹤核心邏輯 \n if current_tracked_def is not None:  ball_node = supervisor.getFromDef(current_tracked_def) \n 每一個 timestep： \n \n \n 讀取球當前位置  pos \n \n \n 若距離上一個軌跡點大於  TRAJECTORY_POINT_STEP ，就新增一個新點 \n \n \n 若超過 5 個點，移除最舊的點 \n \n \n 若球落地（z 低於閾值），刪除所有軌跡點，結束追蹤 \n \n \n \n \n \n \n', 'tags': '', 'url': 'Supervisor 控制程式分析.html'}, {'title': '籃框及其輪車、計分程式分析', 'text': 'from controller import Robot, Keyboard\n\n# Constants\n#TIME_STEP = 32  # Simulation time step in milliseconds\nWHEEL_RADIUS = 0.1  # Radius of the wheels in meters (10cm)\nL = 0.471  # Half of the robot\'s length in meters\nW = 0.376  # Half of the robot\'s width in meters\nMAX_VELOCITY = 10.0  # Maximum velocity allowed for the wheels\n\n# Initialize the robot\nrobot = Robot()\n\n# Get simulation time step\ntimestep = int(robot.getBasicTimeStep())\nemitter = robot.getDevice("score_emitter")\nscore_to_send = 2  # 每次加分2分，可依實際得分修改\n\n# Get the DistanceSensor device\nsensor = robot.getDevice(\'sensor\')\nsensor.enable(timestep)\nscore = 0\nlast_score_time = 0\ncooldown = 1.0\n\n# Initialize the keyboard\nkeyboard = Keyboard()\n#keyboard.enable(TIME_STEP)\nkeyboard.enable(timestep)\n\n\n# Get motor devices\nwheel5 = robot.getDevice("wheel5")  # Front-right wheel\nwheel6 = robot.getDevice("wheel6")  # Front-left wheel\nwheel7 = robot.getDevice("wheel7")  # Rear-right wheel\nwheel8 = robot.getDevice("wheel8")  # Rear-left wheel\n\n# Set motors to velocity control mode\nfor wheel in [wheel5, wheel6, wheel7, wheel8]:\n    wheel.setPosition(float(\'inf\'))  # Enable velocity control\n    wheel.setVelocity(0)  # Set initial velocity to 0\n\ndef set_wheel_velocity(v1, v2, v3, v4):\n    """Set the velocity of all wheels."""\n    wheel5.setVelocity(v1)\n    wheel6.setVelocity(v2)\n    wheel7.setVelocity(v3)\n    wheel8.setVelocity(v4)\n\n# lookupTable 轉成程式用的格式\nlookup_table = [\n    (1000, 0.00),\n    (620, 0.12),\n    (372, 0.13),\n    (248, 0.14),\n    (186, 0.15),\n    (0, 0.18)\n]\n\ndef ad_to_distance(ad_value):\n    # 假設AD值遞減，距離遞增\n    for i in range(len(lookup_table)-1):\n        a0, d0 = lookup_table[i]\n        a1, d1 = lookup_table[i+1]\n        if a1 <= ad_value <= a0:\n            # 線性插值\n            return d0 + (d1 - d0) * (ad_value - a0) / (a1 - a0)\n    # 超出範圍時回傳極值\n    if ad_value > lookup_table[0][0]:\n        return lookup_table[0][1]\n    return lookup_table[-1][1]\n    \n# Main loop\nprint("Use \'E\', \'X\', \'S\', \'D\' keys to control the robot.")\nprint("E: Move forward, X: Move backward, S: Turn left, D: Turn right.")\nprint("Press \'Q\' to quit.")\n\n#while robot.step(TIME_STEP) != -1:\nwhile robot.step(timestep) != -1:\n\n    key = keyboard.getKey()  # Read the key pressed\n    # Read DistanceSensor value\n    sensor_value = sensor.getValue()\n    #print(sensor_value)\n    distance = ad_to_distance(sensor_value)\n    current_time = robot.getTime()\n    #print(sensor_value)\n    # Check if the ball blocks the sensor (you may need to adjust the threshold based on your sensor\'s range)\n    if key == ord(\'M\') or key == ord(\'m\'):\n        print(distance)\n    if key == ord(\'K\') or key == ord(\'k\'):\n        print(distance)\n\n    if distance < 0.11 and (current_time - last_score_time) > cooldown:\n        score +=2\n        print("得分")\n        print(distance)\n        # 假設你偵測到某事件得分時才送出\n        emitter.send(str(score_to_send).encode(\'utf-8\'))\n\n\n    if key == ord(\'E\') or key == ord(\'e\'):\n        # Move forward\n        velocity = MAX_VELOCITY\n        set_wheel_velocity(velocity, velocity, velocity, velocity)\n    elif key == ord(\'X\') or key == ord(\'x\'):\n        # Move backward\n        velocity = -MAX_VELOCITY\n        set_wheel_velocity(velocity, velocity, velocity, velocity)\n    elif key == ord(\'D\') or key == ord(\'d\'):\n        # Turn right\n        velocity = MAX_VELOCITY\n        set_wheel_velocity(-velocity, velocity, -velocity, velocity)\n    elif key == ord(\'S\') or key == ord(\'s\'):\n        # Turn left\n        velocity = MAX_VELOCITY\n        set_wheel_velocity(velocity, -velocity, velocity, -velocity)\n    elif key == ord(\'Q\') or key == ord(\'q\'):\n        # Quit the program\n        print("Exiting...")\n        break\n    else:\n        # Stop the wheels when no key is pressed\n        set_wheel_velocity(0, 0, 0, 0) \n stand_controller.zip \n 初始化區 \n robot = Robot() timestep = int(robot.getBasicTimeStep()) \n \n \n \n robot  是 Webots 控制器的核心物件。 \n \n \n timestep  是模擬的時間間隔。 \n \n \n 設備取得與啟用 \n emitter = robot.getDevice("score_emitter") sensor = robot.getDevice(\'sensor\') sensor.enable(timestep) \n \n \n \n score_emitter ：用來傳送得分的通訊裝置。 \n \n \n sensor ：距離感測器，測量前方是否有物體（如球）。 \n \n \n 控制輪子馬達 \n wheel5 = robot.getDevice("wheel5") # 前右輪 wheel6 = robot.getDevice("wheel6") # 前左輪 wheel7 = robot.getDevice("wheel7") # 後右輪 wheel8 = robot.getDevice("wheel8") # 後左輪 \n \n \n \n 這些是輪子馬達，命名方式符合 Webots 預設定義。 \n \n \n 之後會用  setVelocity()  控制移動。 \n \n \n 鍵盤控制說明 \n keyboard = Keyboard() keyboard.enable(timestep) \n 啟用鍵盤輸入，讓使用者透過鍵盤操控。 \n 感測器轉距離的 lookup 表 \n lookup_table = [  (1000, 0.00),  (620, 0.12),  ... ] \n \n \n \n 感測器回傳的是「AD 值」（類比值），不是公分或公尺。 \n \n \n ad_to_distance(ad_value)  函數將 AD 值轉換為實際距離（透過線性插值）。 \n \n \n 主迴圈：偵測 + 操控 \n while robot.step(timestep) != -1: \n 每次 step： \n \n \n 檢查鍵盤按鍵 → 控制移動（E/X/S/D） \n \n \n 讀取距離感測器 → 如果太近且冷卻結束，就得分 \n \n \n 按  M/K  顯示目前距離 \n \n \n 按  Q  離開模擬 \n \n \n \n \n \n \n 得分邏輯 \n if distance < 0.11 and (current_time - last_score_time) > cooldown: \n 若感測距離小於 0.11 公尺（表示前方有球），而且距離上次得分已經過了 1 秒，則： \n \n \n 加分（此處預設每次加 2 分） \n \n \n 透過 emitter 傳送  score_to_send \n \n \n 鍵盤控制對照 \n E前進 \n X後退 \n D向右 \n S向左 \n M/K印出目前距離 \n Q結束模擬 \n from controller import Supervisor\n\nSEGMENTS = [\n    [1,1,1,1,1,1,0], # 0\n    [0,1,1,0,0,0,0], # 1\n    [1,1,0,1,1,0,1], # 2\n    [1,1,1,1,0,0,1], # 3\n    [0,1,1,0,0,1,1], # 4\n    [1,0,1,1,0,1,1], # 5\n    [1,0,1,1,1,1,1], # 6\n    [1,1,1,0,0,0,0], # 7\n    [1,1,1,1,1,1,1], # 8\n    [1,1,1,1,0,1,1], # 9\n]\nDIGIT_MATERIALS = [\n    [\'a3mat\', \'b3mat\', \'c3mat\', \'d3mat\', \'e3mat\', \'f3mat\', \'g3mat\'], # 百\n    [\'a2mat\', \'b2mat\', \'c2mat\', \'d2mat\', \'e2mat\', \'f2mat\', \'g2mat\'], # 十\n    [\'a1mat\', \'b1mat\', \'c1mat\', \'d1mat\', \'e1mat\', \'f1mat\', \'g1mat\'], # 個\n]\nON_COLOR = [0, 1, 0]\nOFF_COLOR = [0.05, 0.05, 0.05]\n\ndef set_digit(supervisor, digit_index, value):\n    segs = SEGMENTS[value]\n    for i, seg_on in enumerate(segs):\n        mat_node = supervisor.getFromDef(DIGIT_MATERIALS[digit_index][i])\n        if mat_node:\n            mat_node.getField(\'diffuseColor\').setSFColor(ON_COLOR if seg_on else OFF_COLOR)\n        else:\n            print(f"找不到 {DIGIT_MATERIALS[digit_index][i]} 這個DEF")\n\ndef set_display(supervisor, value):\n    value = max(0, min(999, int(value)))\n    h = value // 100\n    t = (value // 10) % 10\n    u = value % 10\n    set_digit(supervisor, 0, h)\n    set_digit(supervisor, 1, t)\n    set_digit(supervisor, 2, u)\n\nsupervisor = Supervisor()\ntimestep = int(supervisor.getBasicTimeStep())\n\nscore = 0\nreceiver = supervisor.getDevice("score_receiver")\nreceiver.enable(timestep)\n\nwhile supervisor.step(timestep) != -1:\n    while receiver.getQueueLength() > 0:\n        data = receiver.getString()\n        if data.isdigit():\n            try:\n                received_score = int(data)\n                score += received_score\n                print(f"收到得分訊息: +{received_score}, 總分: {score}")\n            except Exception as e:\n                print("訊息格式錯誤:", e)\n        receiver.nextPacket()\n    set_display(supervisor, score) \n counter_supervisor.zip \n \n \n 接收來自其他控制器（例如剛剛那台機器人）發送過來的  得分訊息 。 \n \n \n 解析訊息後，把得分累加起來。 \n \n \n 然後根據目前總分，控制三個  7 段顯示器的材質顏色 ，呈現出目前分數（0~999）。 \n \n \n DIGIT_MATERIALS = [  [\'a3mat\', ..., \'g3mat\'], # 百位  [\'a2mat\', ..., \'g2mat\'], # 十位  [\'a1mat\', ..., \'g1mat\'], # 個位 ] \n 這表示三個數字的 7 段顯示器，每一段在 Webots 世界中的  DEF 名稱  例如「百位數的 a 段」是  a3mat ，會對應到場景中一段特定的材質。 \n def set_digit(supervisor, digit_index, value):  ... \n 這個函數用來「控制某一位數字（百／十／個）要顯示什麼數字」，它會根據  SEGMENTS  來打開／關掉那幾段。 \n \n \n digit_index = 0 : 控制百位 \n \n \n digit_index = 1 : 控制十位 \n \n \n digit_index = 2 : 控制個位 \n \n \n 內部用  getFromDef(...)  來抓材質節點，然後把  diffuseColor  設成亮（綠色）或暗（灰色）。 \n def set_display(supervisor, value):  ... \n 這是主函數，會把 0~999 的整數分成三位數來呼叫  set_digit ，更新整個顯示器。 \n supervisor = Supervisor() ... receiver = supervisor.getDevice("score_receiver") \n 這是 Webots 的 supervisor 控制器初始化，並啟用一個  receiver 裝置 ，用來接收得分。 \n while supervisor.step(timestep) != -1:  while receiver.getQueueLength() > 0:  ... \n 每個模擬步驟都檢查有沒有新的資料進來： \n \n \n 如果有新的得分數字（如  2 、 5 ）： \n \n \n 解析字串為整數，累加到總分。 \n \n \n 更新三位數顯示器的顏色狀態。 \n \n \n \n \n \n \n 這段程式 不會產生分數，也不控制機器人 ，只負責「接收分數 → 顯示分數」。 \n \n \n 如果要配合上一段程式使用， 要保證 emitter 對應的 receiver 名稱一致 ，像這邊叫  "score_receiver" 。 \n \n \n 如果 7 段顯示器的材質名字對錯了（DEF 名稱沒對上），會顯示  找不到 XXX 這個DEF  的錯誤訊息。 \n \n \n \n', 'tags': '', 'url': '籃框及其輪車、計分程式分析.html'}, {'title': '期末總結', 'text': '\n 同樣是收獲良多的一門課，痛苦與收穫成正比，估計就是這門課能讓我保有最深的印象，東西也不會隨便忘記。 \n \n \n \n', 'tags': '', 'url': '期末總結.html'}, {'title': 'Brython', 'text': '1 add to 100 \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n \n', 'tags': '', 'url': 'Brython.html'}]};